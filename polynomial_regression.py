# -*- coding: utf-8 -*-
"""Polynomial Regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wgHtbYqK1k8BiJ5qMOYBmMMpFqZhaH_H

##Import all necessary Libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import PolynomialFeatures
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn import metrics
from joblib import dump, load

# %matplotlib inline

"""##Check out the Data"""

df= pd.read_csv('/content/Real estate.csv')

df.head()

print("The Dataset has",df.shape[0],"Rows")
print("The Dataset has",df.shape[1],"Columns")

df.info()

df.corr()

sns.heatmap(df.corr(), annot=True,cmap="YlGnBu")

"""##Exploratory Data Analysis (EDA)"""

sns.pairplot(df)

"""##Define X and y"""

X=df.drop('Y house price of unit area', axis=1)

y=df['Y house price of unit area']

"""## Preprocessing"""

polynomial_converter=PolynomialFeatures(degree=2, include_bias=False)

poly_features=polynomial_converter.fit(X)

poly_features=polynomial_converter.transform(X)

poly_features.shape

X.shape

"""##Train Test Split"""

X_train, X_test, y_train, y_test = train_test_split(
    poly_features, y, test_size=0.3, random_state=101)

"""##Training a Polynomial Regression Model"""

polymodel=LinearRegression()

polymodel.fit(X_train, y_train)

"""##Predicting Test Data"""

y_pred=polymodel.predict(X_test)

pd.DataFrame({'Y_Test': y_test,'Y_Pred':y_pred, 'Residuals':(y_test-y_pred) }).head(5)

"""##Evaluating the Model"""

MAE_Poly = metrics.mean_absolute_error(y_test,y_pred)
MSE_Poly = metrics.mean_squared_error(y_test,y_pred)
RMSE_Poly = np.sqrt(MSE_Poly)

pd.DataFrame([MAE_Poly, MSE_Poly, RMSE_Poly],
             index=['MAE', 'MSE', 'RMSE'], columns=['metrics'])

"""##Compare to the simple linear regression"""

XS_train, XS_test, ys_train, ys_test = train_test_split(X, y, test_size=0.3, random_state=101)
simplemodel=LinearRegression()
simplemodel.fit(XS_train, ys_train)
ys_pred=simplemodel.predict(XS_test)

MAE_simple = metrics.mean_absolute_error(ys_test,ys_pred)
MSE_simple = metrics.mean_squared_error(ys_test,ys_pred)
RMSE_simple = np.sqrt(MSE_simple)

pd.DataFrame({'Poly Metrics': [MAE_Poly, MSE_Poly, RMSE_Poly], 'Simple Metrics':[MAE_simple, MSE_simple,
                                                                                 RMSE_simple]}, index=['MAE', 'MSE', 'RMSE'])

"""##Adjusting Model Parameters"""

# Train List of RMSE per degree
train_RMSE_list=[]
#Test List of RMSE per degree
test_RMSE_list=[]

for d in range(1,10):

    #Preprocessing
    #create poly data set for degree (d)
    polynomial_converter= PolynomialFeatures(degree=d, include_bias=False)
    poly_features= polynomial_converter.fit(X)
    poly_features= polynomial_converter.transform(X)

    #Split the dataset
    X_train, X_test, y_train, y_test = train_test_split(poly_features, y, test_size=0.3, random_state=101)

    #Train the Model
    polymodel=LinearRegression()
    polymodel.fit(X_train, y_train)

    #Predicting on both Train & Test Data
    y_train_pred=polymodel.predict(X_train)
    y_test_pred=polymodel.predict(X_test)

    #Evaluating the Model

    #RMSE of Train set
    train_RMSE=np.sqrt(metrics.mean_squared_error(y_train, y_train_pred))

    #RMSE of Test Set
    test_RMSE=np.sqrt(metrics.mean_squared_error(y_test, y_test_pred))

    #Append the RMSE to the Train and Test List

    train_RMSE_list.append(train_RMSE)
    test_RMSE_list.append(test_RMSE)

pd.DataFrame({'Train RMSE List':train_RMSE_list})

pd.DataFrame({'Ttest RMSE List':test_RMSE_list})

"""##Plot the Polynomial degree VS RMSE"""

plt.plot(range(1,6), train_RMSE_list[:5], label='Train RMSE')
plt.plot(range(1,6), test_RMSE_list[:5], label='Test RMSE')

plt.xlabel('Polynomial Degree')
plt.ylabel('RMSE')
plt.legend()

